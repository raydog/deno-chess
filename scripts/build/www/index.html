<html>
  <head>
    <link rel="stylesheet"
      href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
      integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU"
      crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
      integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2"
      crossorigin="anonymous"></script>

    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
      integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD"
      crossorigin="anonymous"></script>
    
    <!-- TODO: Better mod name. It's 1:40am... -->
    <script src="js/mod.js"></script>
  </head>
  <body>
    <div id="board" style="width: 400px"></div>

  <script>
    $(function() {

      var BEST_BLUE = "#4353FF";

      var game = DenoChess.ChessGame.NewStandardGame();
      var ai = DenoChess.BeginnerAI.NewForGame(game, "black");

      var status, moves;
      var highlighted = [];

      refreshState();

      var board = Chessboard('board', {
        draggable: true,
        position: 'start',
        dropOffBoard: 'snapback',
        showNotation: true,
        onDragStart: onDragStart,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd
      });

      function onDragStart (source, piece, position, orientation) {

        highlight(
          moves
            .filter(move => move.startsWith(source))
            .map(move => move.slice(2))
        );
        
        // do not pick up pieces if the game is over
        if (game.isGameOver()) { return false; }

        // only pick up pieces for the side to move
        if ((status.turn === 'white' && piece.startsWith("b")) ||
            (status.turn === 'black' && piece.startsWith("w"))) {
          return false
        }
      }

      function onDrop (source, target) {
        
        clearHighlights();

        if (target === "offboard" || source === target) {
          return "snapback";
        }
        
        try {
          var move = game.move(source + target, 'Q');
          refreshState();

        } catch (ex) {
          console.error(ex.message);
          return 'snapback';
        }

        // Let AI take a turn:
        try {
          ai.takeTurn();
          refreshState();

        } catch (ex) {
          console.error("AI Error", ex.message);
        }
      }

      // update the board position after the piece snap
      // for castling, en passant, pawn promotion
      function onSnapEnd () {
        board.position(game.toString("fen"))
      }

      function refreshState() {
        status = game.getStatus();
        moves = game.allMoves();
      }

      function highlight(squares) {
        squares.forEach(pos => {
          $("#board .square-" + pos)
            .css("box-sizing", "border-box")
            .css("box-shadow", "inset 0 0 3px 3px " + BEST_BLUE);
          highlighted.push(pos);
        })
      }

      function clearHighlights() {
        highlighted.forEach(pos => {
          $("#board .square-" + pos)
            .css("box-shadow", "none");
        });
        highlighted.length = 0;
      }
    });
  </script>
  </body>
</html>
